### 240612 리뷰

1. 요구사항이 수정, 추가 되었을 때 확장 가능한 설계가 되도록 해야한다.

### 240613 내용 정리

- 모든 클래스는 오브젝트 클래스를 가지고 있다
- Dart의 `Object` 클래스에는 `==` 연산자를 비롯한 메서드들이 구현되어 있다.  ==는 오브젝트가 제공하는 기능
- 하위 클래스에서 `==` 연산자를 오버라이드하지 않았다면, 기본적으로는 두 객체의 메모리 주소를 비교한다
- 해시코드와 메모리 주소는 다르나 같다고 봐도 무방
- 해시코드: 객체를 표현하는 숫자
- ctrl + f12 , ctrl + b: structure 알 수 있는 단축키
- 모든 Dart 클래스는 암묵적으로 `Object` 클래스를 상속받기 때문에 `toString()` 메서드를 가지고 있다
- indentical은 진짜로 메모리 주소가 같은지 확인하는 것

```dart
 @override
  bool operator ==(Object other) =>
      identical(this, other) ||
          other is Person &&
              runtimeType == other.runtimeType &&
              name == other.name &&
              age == other.age;
```

- 해시 테이블은 보통 O(1) 시간 복잡도를 갖는디 (항상 속도가 똑같다)

> O(n)은 알고리즘의 실행 시간이 입력 크기에 비례하여 증가하는 것으로, 입력 크기가 증가함에 따라 실행 시간도 선형적으로 증가
> 

> O(1)은 알고리즘의 실행 시간이 입력 크기와 무관하게 일정한 것으로, 상수 시간이라고도 합니다. 입력 크기에 관계없이 항상 동일한 실행 시간을 갖는다
> 
- String 클래스 자체는 안에 내용이 같으면 동일한 해시값이 나오게 되어있다
- ==과 해시코드 둘 다 generate로 생성할 수 있다
- sort는 내부의 데이터를 정렬해준다
- `Comparable` 인터페이스가 구현되어 있어야만 Dart의 `sort()` 함수를 사용하여 요소들을 정렬할 수 있다
- `Comparable` 함수 오버라이드 하면 됨.  거꾸로 하고 싶으면 -로 바꿔주자

```dart
@override
  int compareTo(Hero hero){
    return name.compareTo(other.name) * -1;
  }
```

- 직접 만든 클래스의 객체가 `sort()` 함수와 함께 동작하지 않는 이유는 해당 클래스가 `Comparable` 인터페이스를 구현하지 않았기 때문
- Dart에서는 `sort()` 함수를 사용하여 리스트를 정렬할 때, 기본적으로 요소들이 `Comparable` 인터페이스를 구현하고 있어야 한다
- 만든 클래스의 객체를 `sort()` 함수와 함께 사용하려면 해당 클래스가 `Comparable` 인터페이스를 구현하도록 해야 하며, 비교 연산을 정의하는 `compareTo()` 메서드를 구현해야 한다
- 인스턴스를 복사하고 싶을 떄 dart는 깊은 복사를 지원 안해서 `copyWith` 메서드를 사용해야한다
- `copyWith`메서드는 일부 필드를 변경한 객체의 복사본을 생성하는 데 사용. 일부 필드 만 수정할 수 있다
- == 연산자, 해시코드, copyWith, compareTo 메서드를 구현해놓은 클래스라고 정의한다