typedef : 타입 재정의를 할때 사용한다
- typedef PhotoResultError = Error<List<Photo>, PhotoRepositoryError>;

static 있는 클래스는 abstract를 붙이는게 더 낫다 (인스턴스를 만들지 않기 위해서)
아무일도 하지 않는 클래스라서 abstract를 붙이는 것이 더 좋다

```dart
  abstract class PhotoRepository {
  Future<PhotoResultError> fetchPhotos();
}
```

key 같은 경우는 직접 올리지 말자 / 로컬 파일로 관리하면 좋다
- 플러터에서는 flutter_dotenv 패키지를 이용해서 하면 편하다

final int _max = 9223372036854775807 + 1 이 최대값인데
여기에 + 1을 하면 - 9223372036854775808 이런값이 나온다 (기본상식 - 벵글벵글 돈다)

재귀 호출 - 자기 자신을 계속 호출해서 메모리에 쌓이다가 
          return 을 받으면 한번에 다 돌려줘서 터지는? 경우가 있어서 주의해야 한다

꼬리 재귀 - 재귀 호출을 하면서 계속해서 메모리에 쌓이는 것을 방지하기 위해서
          return을 받으면서 계속해서 돌려주는 방식으로 메모리를 적게 사용할 수 있다
          dart는 꼬리 재귀를 지원하지 않는다

좋은 코드를 위해 의식해야 하는 6가지 코드 원칙

- DRY : Don't Repeat Yourself (중복을 피하라)
  1. 중복 코드를 제거하자(메소드로 분리하자)
  
- PIE : Program to an Intetly, and Expressively (명확하고 표현력 있게 프로그래밍 하라)
  1. 코드를 읽는 사람이 이해하기 쉽게 작성
  2. 쉬운 이름을 사용하자
  3. 컨벤션을 따르자
  4. 매직 넘버에 이름을 붙이자(숫자를 직접 사용하지 말고 이름을 붙여서 사용) 

- SRP : Single Responsibility Principle (단일 책임 원칙)
  1. 클래스는 하나의 책임만 가져야 한다 (단일 책임 원칙)
  2. 에러 수정 시 다른 클래스에 영향을 주지 않도록 한다, 그 클래스만 수정하면 되게 하자
  3. 클래스 분리가 너무 많아도 오히려 관리가 어려울 수 있다 (적당히)

- OCP : Open/Closed Principle (개방-폐쇄 원칙)
  1. 확장에는 열려있고 변경에는 닫혀 있어야 한다 (개방-폐쇄 원칙)
  2. 새로운 기능이 추가되어도 기존 코드를 수정하지 않고 확장할 수 있게 하자
  3. 인터페이스를 사용하면 쉽게 확장이 가능하다
  4. 상속을 사용하면 확장이 어렵다
  5. String 상속 금지이므로 확장이 어렵다
  6. Iterable, Comparator 등을 사용하면 확장이 쉽다

- SDP : Stable Dependencies Principle (안정된 의존성 원칙)
  1. 안정된 클래스는 변경되지 않아야 한다
  2. 안정된 클래스는 다른 클래스에 의존하면 안된다
  3. 안정된 클래스는 인터페이스에 의존해야 한다
  4. 안정된 클래스는 구체 클래스에 의존하면 안된다

- ADP : Acyclic Dependencies Principle (비순환 의존성 원칙) 
  1. 의존성 비순환 원칙은 순환 의존성을 피해야 한다
  2. 순환 의존성은 코드를 이해하기 어렵게 만든다
  3. 순환 의존성은 테스트하기 어렵게 만든다
  4. 순환 의존성은 코드를 변경하기 어렵게 만든다
  5. 순환 의존성은 코드를 확장하기 어렵게 만든다
  6. 순환 의존성은 코드를 재사용하기 어렵게 만든다



설계원칙 : SOLID
- 단일 책임 원칙(Single Responsibility Principle)
- 개방-폐쇄 원칙(Open-Closed Principle)
- 리스코프 치환 원칙(Liskov Substitution Principle)
- 인터페이스 분리 원칙(Interface Segregation Principle)
- 의존 역전 원칙(Dependency Inversion Principle)

상속 = 확장 / 변경 = 수정
1. 단일책임원칙 : 클래스는 하나의 책임만 가져야 한다 - 외부 객체는 생성자로 주입받아라
    (Slime, goblin, Character 클래스를 분리하자)
2. 개방폐쇄원칙 : 확장에는 열려있고 변경에는 닫혀 있어야 한다 - (Slime, goblin 각각 공격하지 말고 Character로 공격하게 하자)
   인터페이스를 파라미터로 받으면 수정하지 않아도 기능 확장(적용)이 가능하다
3. 리스코프치환원칙 : 자식클래스는 부모클래스에서 가능한 행위를 수행할 수 있어야 한다 (is - a 원칙)
    (Slime, goblin이 Character를 상속받아서 공격을 할 수 있게 하자)
4. 인터페이스분리원칙 : 클라이언트는 자신이 사용하지 않는 메서드에 의존하면 안된다 
   (인터페이스 1개에 모든 기능을 넣지 말고, 기능별로 나눠서 사용하자[attackble, moveable, flyable, runable, swimable, jumpable])
5. 의존관계 역전원칙 : 추상화에 의존해야 하며 구체화에 의존하면 안된다
   (메딕 캐릭터가 특정 객체를 파라미터로 받지 말고 인터페이스를 받아서 사용하게 하자[Healable interface 구현체를 받도록 하는것])



디자인 패턴
- software design pattern : 소프트웨어 설계시 특정 문맥에서 공통적으로 자주 발생하는 문제에 대해 재사용 가능한 해결책
- 디자인 패턴의 장점 : 코드의 재사용성, 코드의 유지보수성, 코드의 가독성, 유연성, 확장성
- 디자인 패턴의 종류 : 생성 패턴, 구조 패턴, 행위 패턴
  - 생성 패턴 : 객체 생성에 관련된 패턴(싱글턴 패턴, 팩토리 패턴, 빌더 패턴 등등)
              1. 싱글턴 패턴 : 객체를 하나만 생성하고, 이후에 생성된 객체를 리턴하는 패턴(1개의 인스턴스가 공유된다)
              2. 팩토리 패턴 : 객체를 생성하는 인터페이스를 정의하고, 이를 구현한 클래스에서 객체를 생성하는 패턴
  - 구조 패턴 : 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴 (데커레이터 패턴, 퍼사드 패턴 등등)
              1. 데커레이터 패턴 : 객체에 추가적인 요소를 동적으로 추가하는 패턴
              2. 퍼사드 패턴 : 복잡한 서브시스템을 간단하게 제공하는 인터페이스를 제공하는 패턴(Repository 패턴)
              3. 이터레이터 패턴 : 반복 구조 객체를 통해 요소를 순차적으로 접근하는 패턴
  - 행위 패턴 : 객체나 클래스 사이의 알고리즘과 책임 분배에 관련된 패턴 (전략패턴, 이터레이터 패턴, 옵서버 패턴 등등)
              1. 전략 패턴 : 
              2. 옵서버 패턴 : 객체의 상태 변화를 관찰하는 객체를 등록하고, 상태 변화가 있을 때 메서드를 호출하는 패턴(발행/구독 모델)