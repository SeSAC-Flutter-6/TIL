published: 2024-06-20

## 배운 것
### 동기와 비동기
동기: 코드가 위에서 아래 순서로 실행됨
비동기: 코드의 실행 순서가 보장되지 않음

Dart에서 비동기는 주로 Future 함수로 사용함
네트워크 통신이나 I.O 작업 등 소요 시간이 불확실하고 오래 걸리는 작업들,
굳이 작업의 종료를 기다릴 필요가 없는 작업들을 비동기로 실행함.

```dart
// Future 함수의 선언부에는 async 키워드를 명시해야함
Future<T> work() async {
	...
}
```

비동기적으로 동작하는 Future 함수의 순서를 보장하고 싶을 때는 await 키워드를 쓸 수 있음.
기존에는 비동기 함수의 순서를 보장할 때 call-back 함수를 사용하는 방식으로 사용해왔으나, 여러 비동기 함수들이 중첩될 경우 콜백의 depth가 깊어져 가독성이 현저히 낮아짐.

Swift도 Swift Concurrency가 도입되면서 async await을 지원함.
함수의 리턴 타입을 별도로 래핑하지는 않기 때문에 더 쉽게 배웠던 것 같음.
### 동시성과 병렬
![](https://i.imgur.com/gsqDIVz.png)
동시성은 싱글 코어에서 멀티 스레드를 운용하여 동시에 처리하는 것처럼 보이지만, 실제로는 한 번에 하나의 스레드를 사용하는 것.
![](https://i.imgur.com/NBWa3J5.png)
병렬은 멀티 코어에서 멀티 스레드를 운용하여 실제로 동시에 작업을 처리하는 것임.

따라서 병렬은 물리적인 개념이지만, 동시성은 논리적인 개념임.
즉, 멀티 코어가 각각 멀티 쓰레드를 운용하여 병렬로 작업을 처리하지만, 멀티 쓰레드를 동시성 처리할 수도 있는 것.

### 다트는 싱글 스레드인데?
얼핏 듣기로는 다트는 싱글 스레드라고 들었었음. 그러나 정확하게는 스레드보다 상위 개념인 isolate(격리)가 존재함.

단순하게 생각하면 힙 메모리를 공유하던 다중 스레드 환경에서
뮤텍스, 락과 같은 데드락 상황을 물리적으로 예방하기 위해서 isolate라는 개념을 도입하였음.

isolate는 단일 스레드와 독립적인 힙 메모리를 가짐.
또한, isolate끼리는 각각의 상태에 접근도, 공유도 할 수 없음(메시지 통신은 할 . 수 있다고 하는데, 여기서는 생략)

따라서 다트는 기본적으로 Main isolate에서 모든 작업을 수행하고, isolate는 하나의 스레드만 가지기 때문에 싱글 스레드라고 말할 수 있었던 것.

근데 하나의 스레드로는 I.O나 Json 파싱, 네트워크 통신 등의 무거운 작업을 UI 작업과 함께 처리하기에는 한계가 있을텐데?

그래서 다트 역시 Main Isolate에서 처리하기 무거운 작업들은 별도의 isolate를 만들어 병렬 처리할 수 있음.


![](https://i.imgur.com/zWKVTX3.png)

또한, 단일 스레드에서 이벤트 루프라는 큐를 통해 비동기 작업들을 처리함.
동기 작업들은 main 함수 내에서 처리되고, main 함수가 종료되면 이벤트 루프가 돌면서 이벤트 큐에 있는 비동기 함수들의 콜백들을 처리하는 것.

## 느낀 점 
Swift에도 Main Loop라는 개념이 있어서 Dart의 이벤트 루프와 상당히 비슷한 메커니즘이라고 느꼈음.
Dart의 isolate는 스레드 간의 충돌을 예방하기 위해서 새롭게 도입된 개념인 듯.
힙 메모리를 공유할 수 있음으로서 오는 장단에서 장점을 버리고 단점을 원천 차단한 방안. 자세한 것들은 실제로 플러터 앱을 만들면서 몸소 체험해보자.
## 참고 자료
[Concurrency | Dart](https://dart.dev/language/concurrency)