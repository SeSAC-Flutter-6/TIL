## Singleton Pattern

 ### 정의  
 

    💡 클래스의 인스턴스를 하나만 생성하고, 생성된 인스턴스는 어디에서든지 접근할 수 있도록 보장하는 디자인 패턴

    

### 사용 이유

- 객체를 한 번만 생성해 메모리 낭비 방지
- 여러 클래스의 인스턴스가 공통된 자원 공유 가능
- 공통된 자원 관리에 사용함


### 장점

- 전역적으로 접근 가능한 인스턴스 제공
- 객체의 생성을 제어 가능

### 단점

- 테스트 어려움
  - 왜? 싱글턴 패턴은 전역 상태를 가지므로 테스트 격리가 어렵고, 상태를 제어하기 어렵다
- multi shread 환경에서 동기화 문제 발생
  - 왜? 멀티 스레드 환경에서 싱글턴 인스턴스를 처음 생성할 때, 여러 스레드가 동시에 접근하려고 하면 여러 인스턴스가 생성되는 경쟁 조건이 발생할 수 있음.
  - 경쟁조건? 두 개 이상의 스레드가 공유 자원에 동시에 접근하여 일관성 없는 상태를 만들 수 있는 상황
  - 스레드가 뭔데?
    - 프로세스 내에서 실행되는 가장 작은 단위의 실행 흐름. 
    - 한 프로세스 내에는 여러 스레드가 존재할 수 있으며, 이들은 같은 메모리 공간을 공유함.
    - 스레드는 프로세스의 코드 영역, 데이터 영역, 힙 영역을 공유하지만, 각각 자신만의 스택 영역을 가진다.
    - like 형태소?

### 예제 코드 (Dart)

```dart
class Singleton {
  static final Singleton _instance = Singleton._internal();

  factory Singleton() {
    return _instance;
  }

  Singleton._internal() {
    // 초기화 코드
  }

  void someMethod() {
    print('싱글톤 메서드 호출');
  }
}

void main() {
  var singleton1 = Singleton();
  var singleton2 = Singleton();

  print(singleton1 == singleton2); // true
  singleton1.someMethod();
}

```

---

## 2. 팩토리 패턴 (Factory Pattern)

### 정의

💡 객체를 생성하는 인터페이스를 정의하고, 어떤 클래스의 인스턴스를 생성할지 서브 클래스에서 결정하는 디자인 패턴  
자동차 공장을 인터페이스로 정의하고, 구체적인 자동차 브랜드(예: 벤츠, BMW)를 생성


### 사용 이유

- 객체 생성 코드를 한 곳에 모아 관리 가능
- 객체 생성 로직을 변경해도 다른 코드에 영향을 주지 않음 (벤츠 디자인 바꾼다고 BMW도 바뀌지 않음)
- 다양한 종류의 객체를 동적으로 생성해야 할 때 사용

### 장점

- 객체 간의 결합도를 낮춰 유지보수가 용이
- 같은 인터페이스에서부터 파생된 객체들을 한 곳에서 관리할 수 있음
  - 공통 인터페이스(CarFactory)가 정의되어 있으며, 이 인터페이스를 구현하는 여러 구체적인 클래스(BenzFactory, BMWFactory 등)가 존재.
  - CarFactory 인터페이스를 통해 모든 자동차 생성 로직을 한 곳에서 관리할 수 있음. 

### 단점

- 불필요하게 많은 클래스를 정의하는 경우가 생김
- 구조가 더 복잡해질 수 있음
